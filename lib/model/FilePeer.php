<?php



/**
 * Skeleton subclass for performing query and update operations on the 'file' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.5.6 on:
 *
 * Mon Oct 24 09:36:19 2011
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    propel.generator.lib.model
 */
class FilePeer extends BaseFilePeer {

  const ADDED    = 'A';
  const MODIFIED = 'M';
  const DELETED  = 'D';

  /**
   * @static
   * @param Branch $branch
   * @return 0 if succeed
   */
  public static function synchronize(Branch $branch, $lastBranchSynchronizationCommit = null)
  {
    $filesGit = GitCommand::getDiffFilesFromBranch($branch->getRepository()->getGitDir(), $branch->getCommitReference(), $branch->getLastCommit());

    if(count($filesGit) > sfConfig::get('app_max_number_of_files_to_review', 4096))
    {
      return count($filesGit);
    }

    $filesModel = FileQuery::create()
      ->filterByBranchId($branch->getId())
      ->find()
    ;

    if(count($filesModel) > 0)
    {
      $diffFilesFromLastSynch = GitCommand::getDiffFilesFromBranch($branch->getRepository()->getGitDir(), (!is_null($lastBranchSynchronizationCommit)) ? $lastBranchSynchronizationCommit : $branch->getCommitReference(), $branch->getLastCommit(), false);
    }

    foreach ($filesModel as $fileModel)
    {
      /** @var $fileModel File */
      if(!array_key_exists($fileModel->getFilename(), $filesGit))
      {
        $fileModel->delete();
      }
      else
      {
        $lastChangeCommit = GitCommand::getLastModificationCommit($branch->getRepository()->getGitDir(), $branch->getName(), $fileModel->getFilename());

        if(isset($diffFilesFromLastSynch[$fileModel->getFilename()]))
        {
          $fileModel->setReviewRequest(true)
            ->setStatus(BranchPeer::A_TRAITER)
            ->setCommitStatusChanged($lastChangeCommit)
          ;
        }
        else
        {
          $fileModel->setReviewRequest(false);
        }

        $fileModel->setState($filesGit[$fileModel->getFilename()]['state'])
          ->setLastChangeCommit($lastChangeCommit)
          ->setCommitInfos(GitCommand::getCommitInfos($branch->getRepository()->getGitDir(), $lastChangeCommit, "%ce %s"))
          ->setNbAddedLines($filesGit[$fileModel->getFilename()]['added-lines'])
          ->setNbDeletedLines($filesGit[$fileModel->getFilename()]['deleted-lines'])
          ->setCommitReference($branch->getCommitReference())
          ->save();
        ;
      }

      unset($filesGit[$fileModel->getFilename()]);
    }

    foreach ($filesGit as $fileGit)
    {
      $lastChangeCommit = GitCommand::getLastModificationCommit($branch->getRepository()->getGitDir(), $branch->getName(), $fileGit['filename']);
      $file = new File();
      $file->setFilename($fileGit['filename'])
        ->setStatus(BranchPeer::A_TRAITER)
        ->setState($fileGit['state'])
        ->setBranchId($branch->getId())
        ->setLastChangeCommit($lastChangeCommit)
        ->setCommitInfos(GitCommand::getCommitInfos($branch->getRepository()->getGitDir(), $lastChangeCommit, "%ce %s"))
        ->setNbAddedLines($fileGit['added-lines'])
        ->setNbDeletedLines($fileGit['deleted-lines'])
        ->setCommitReference($branch->getCommitReference())
        ->setReviewRequest(true)
        ->save()
      ;
    }

    return 0;
  }
} // FilePeer
